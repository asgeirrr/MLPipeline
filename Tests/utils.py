import random
import string
from typing import List, Tuple

from MLPipeline.pipeline_task import TaskFactory


def rand_string(length: int) -> str:
    return ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(length))


def create_dummy_component(inputs: List[str], runner: str) -> Tuple[dict, str]:
    component_name = f'{runner}_{rand_string(5)}'
    outputs = [
        f"{rand_string(5)}" for _ in range(random.randint(1, 3))
    ]
    return {
               component_name: {
                   'inputs': inputs,
                   'outputs': outputs,
                   'runner': runner
               }
           }, component_name


def create_dummy_pipeline_dict(
        depth: int,
        no_inputs: int,
        no_outputs: int,
        max_components_per_level: int,
        name: str = 'dummy_pipeline'
) -> dict:
    """
    Returns dict which represent dummy pipeline,
    number of tasks would range from depth to depth*max_components_per_level.
    no_inputs, no_outputs declare how many inputs/outputs should pipeline have.
    """

    # get available runners
    task_factory = TaskFactory()
    task_factory.known_runners.pop('AbstractTask')
    runners_list = list(task_factory.known_runners.keys())

    # generate pipeline inputs
    base_inputs = [f'input_{i}' for i in range(no_inputs)]

    # inputs contain all consumables that will be generated by components
    inputs = []
    # list of components
    components = []

    # for each layer
    for layer in range(depth):
        layer_components = random.randint(1, max_components_per_level)

        # generate up to max_components_per_level components
        for component in range(layer_components):
            # which chose inputs from available inputs so far and runner from available runners
            new_component, new_component_name = create_dummy_component(
                random.sample(inputs + base_inputs, min(len(inputs + base_inputs), 3)),
                random.choice(runners_list)
            )

            components.append(new_component)
            inputs.extend([f'{new_component_name}.{output}' for output in new_component[new_component_name]['outputs']])

    pipeline = {
        'pipeline': {
            'name': name,
            'inputs': base_inputs,
            'outputs': random.sample(inputs, min(len(inputs), no_outputs)),
            'components': components
        }
    }

    return pipeline
